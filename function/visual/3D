-- Optimized 3D Box ESP Script
-- Services
local RunService = game:GetService("RunService")
local PlayersService = game:GetService("Players")

-- Variables
local Camera = workspace.CurrentCamera
local LocalPlayer = PlayersService.LocalPlayer
local PlayerESPData = {}
local ESPConnection = nil
local ESPEnabled = true
local LastUpdateTime = 0
local UPDATE_RATE = 1/45 -- 45 FPS cap for 3D ESP (more intensive)

-- Settings
local Settings = {
    MaxDistance = 800, -- Reduced max distance for 3D ESP
    LineThickness = 1,
    LineColor = Color3.fromRGB(255, 255, 255),
    FillColor = Color3.fromRGB(255, 255, 255),
    FillTransparency = 0.25,
    BoxSize = Vector3.new(3, 5, 3)
}

-- Functions
local function HasCharacter(Player)
    return Player and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") and Player ~= LocalPlayer
end

local function CreateLine()
    local Line = Drawing.new("Line")
    Line.Thickness = Settings.LineThickness
    Line.Color = Settings.LineColor
    Line.Transparency = 1
    Line.ZIndex = 1
    Line.Visible = false
    return Line
end

local function CreateQuad()
    local Quad = Drawing.new("Quad")
    Quad.Thickness = 0.5
    Quad.Color = Settings.FillColor
    Quad.Transparency = Settings.FillTransparency
    Quad.ZIndex = 1
    Quad.Filled = true
    Quad.Visible = false
    return Quad
end

local function CreatePlayerESP(Player)
    if PlayerESPData[Player] then return end
    
    PlayerESPData[Player] = {
        Lines = {},
        Quads = {},
        LastPosition = Vector3.new(0, 0, 0),
        LastUpdate = 0,
        CachedVertices = {}
    }
    
    -- Create 12 lines for 3D box edges
    for i = 1, 12 do
        PlayerESPData[Player].Lines[i] = CreateLine()
    end
    
    -- Create 6 quads for 3D box faces
    for i = 1, 6 do
        PlayerESPData[Player].Quads[i] = CreateQuad()
    end
end

local function RemovePlayerESP(Player)
    if not PlayerESPData[Player] then return end
    
    -- Clean up lines
    for _, line in pairs(PlayerESPData[Player].Lines) do
        if line then
            line:Remove()
        end
    end
    
    -- Clean up quads
    for _, quad in pairs(PlayerESPData[Player].Quads) do
        if quad then
            quad:Remove()
        end
    end
    
    PlayerESPData[Player] = nil
end

-- Get corners function (vertices) - optimized
local function GetCorners(CF, Size)
    local HalfSize = Size / 2
    return {
        (CF * CFrame.new(-HalfSize.X, -HalfSize.Y, -HalfSize.Z)).Position, -- 1
        (CF * CFrame.new(HalfSize.X, -HalfSize.Y, -HalfSize.Z)).Position,  -- 2
        (CF * CFrame.new(-HalfSize.X, HalfSize.Y, -HalfSize.Z)).Position,  -- 3
        (CF * CFrame.new(HalfSize.X, HalfSize.Y, -HalfSize.Z)).Position,   -- 4
        (CF * CFrame.new(-HalfSize.X, -HalfSize.Y, HalfSize.Z)).Position,  -- 5
        (CF * CFrame.new(HalfSize.X, -HalfSize.Y, HalfSize.Z)).Position,   -- 6
        (CF * CFrame.new(-HalfSize.X, HalfSize.Y, HalfSize.Z)).Position,   -- 7
        (CF * CFrame.new(HalfSize.X, HalfSize.Y, HalfSize.Z)).Position     -- 8
    }
end

local function WorldToScreen(Position)
    local ScreenPos, OnScreen = Camera:WorldToViewportPoint(Position)
    return Vector2.new(ScreenPos.X, ScreenPos.Y), OnScreen
end

local function UpdateLine(Line, From, To)
    local FromScreen, FromVisible = WorldToScreen(From)
    local ToScreen, ToVisible = WorldToScreen(To)
    
    if FromVisible or ToVisible then
        Line.From = FromScreen
        Line.To = ToScreen
        Line.Visible = true
        return true
    else
        Line.Visible = false
        return false
    end
end

local function UpdateQuad(Quad, PosA, PosB, PosC, PosD)
    local PosAScreen, PosAVisible = WorldToScreen(PosA)
    local PosBScreen, PosBVisible = WorldToScreen(PosB)
    local PosCScreen, PosCVisible = WorldToScreen(PosC)
    local PosDScreen, PosDVisible = WorldToScreen(PosD)

    if PosAVisible or PosBVisible or PosCVisible or PosDVisible then
        Quad.PointA = PosAScreen
        Quad.PointB = PosBScreen
        Quad.PointC = PosCScreen
        Quad.PointD = PosDScreen
        Quad.Visible = true
        return true
    else
        Quad.Visible = false
        return false
    end
end

local function UpdatePlayerESP(Player)
    if not HasCharacter(Player) or not PlayerESPData[Player] then return end
    
    local Character = Player.Character
    local HRP = Character.HumanoidRootPart
    local Humanoid = Character:FindFirstChild("Humanoid")
    
    if not Humanoid or Humanoid.Health <= 0 then
        -- Hide ESP for dead players
        for _, line in pairs(PlayerESPData[Player].Lines) do
            line.Visible = false
        end
        for _, quad in pairs(PlayerESPData[Player].Quads) do
            quad.Visible = false
        end
        return
    end
    
    -- Distance check for performance
    local distance = (Camera.CFrame.Position - HRP.Position).Magnitude
    if distance > Settings.MaxDistance then
        for _, line in pairs(PlayerESPData[Player].Lines) do
            line.Visible = false
        end
        for _, quad in pairs(PlayerESPData[Player].Quads) do
            quad.Visible = false
        end
        return
    end
    
    -- Check if position changed significantly (optimization)
    local currentPos = HRP.Position
    local lastPos = PlayerESPData[Player].LastPosition
    if (currentPos - lastPos).Magnitude < 1 and tick() - PlayerESPData[Player].LastUpdate < 0.15 then
        return -- Skip update if player hasn't moved much
    end
    
    PlayerESPData[Player].LastPosition = currentPos
    PlayerESPData[Player].LastUpdate = tick()
    
    -- Calculate box size based on distance
    local scaledSize = Settings.BoxSize * math.clamp(1, 0.5, 2)
    
    -- Get cube vertices
    local BoxCFrame = HRP.CFrame * CFrame.new(0, -0.5, 0)
    local CubeVertices = GetCorners(BoxCFrame, scaledSize)
    
    -- Cache vertices for this frame
    PlayerESPData[Player].CachedVertices = CubeVertices
    
    local lines = PlayerESPData[Player].Lines
    local quads = PlayerESPData[Player].Quads
    
    -- Update lines (12 edges of cube)
    local lineIndex = 1
    
    -- Bottom face edges
    UpdateLine(lines[lineIndex], CubeVertices[1], CubeVertices[2]); lineIndex = lineIndex + 1
    UpdateLine(lines[lineIndex], CubeVertices[2], CubeVertices[6]); lineIndex = lineIndex + 1
    UpdateLine(lines[lineIndex], CubeVertices[6], CubeVertices[5]); lineIndex = lineIndex + 1
    UpdateLine(lines[lineIndex], CubeVertices[5], CubeVertices[1]); lineIndex = lineIndex + 1
    
    -- Top face edges
    UpdateLine(lines[lineIndex], CubeVertices[3], CubeVertices[4]); lineIndex = lineIndex + 1
    UpdateLine(lines[lineIndex], CubeVertices[4], CubeVertices[8]); lineIndex = lineIndex + 1
    UpdateLine(lines[lineIndex], CubeVertices[8], CubeVertices[7]); lineIndex = lineIndex + 1
    UpdateLine(lines[lineIndex], CubeVertices[7], CubeVertices[3]); lineIndex = lineIndex + 1
    
    -- Vertical edges
    UpdateLine(lines[lineIndex], CubeVertices[1], CubeVertices[3]); lineIndex = lineIndex + 1
    UpdateLine(lines[lineIndex], CubeVertices[2], CubeVertices[4]); lineIndex = lineIndex + 1
    UpdateLine(lines[lineIndex], CubeVertices[5], CubeVertices[7]); lineIndex = lineIndex + 1
    UpdateLine(lines[lineIndex], CubeVertices[6], CubeVertices[8])
    
    -- Update quads (6 faces of cube) - only if close enough for performance
    if distance < Settings.MaxDistance * 0.7 then
        UpdateQuad(quads[1], CubeVertices[1], CubeVertices[2], CubeVertices[6], CubeVertices[5]) -- Bottom
        UpdateQuad(quads[2], CubeVertices[3], CubeVertices[4], CubeVertices[8], CubeVertices[7]) -- Top
        UpdateQuad(quads[3], CubeVertices[1], CubeVertices[3], CubeVertices[4], CubeVertices[2]) -- Front
        UpdateQuad(quads[4], CubeVertices[5], CubeVertices[6], CubeVertices[8], CubeVertices[7]) -- Back
        UpdateQuad(quads[5], CubeVertices[1], CubeVertices[5], CubeVertices[7], CubeVertices[3]) -- Left
        UpdateQuad(quads[6], CubeVertices[2], CubeVertices[4], CubeVertices[8], CubeVertices[6]) -- Right
    else
        -- Hide quads when far away
        for _, quad in pairs(quads) do
            quad.Visible = false
        end
    end
end

local function BoxESP()
    if not ESPEnabled then return end
    
    -- Rate limiting
    local currentTime = tick()
    if currentTime - LastUpdateTime < UPDATE_RATE then return end
    LastUpdateTime = currentTime
    
    local Players = PlayersService:GetPlayers()
    
    -- Remove ESP for players who left
    for Player, _ in pairs(PlayerESPData) do
        if not table.find(Players, Player) then
            RemovePlayerESP(Player)
        end
    end
    
    -- Update ESP for current players
    for _, Player in pairs(Players) do
        if HasCharacter(Player) then
            CreatePlayerESP(Player)
            UpdatePlayerESP(Player)
        elseif PlayerESPData[Player] then
            -- Hide ESP for players without character
            for _, line in pairs(PlayerESPData[Player].Lines) do
                line.Visible = false
            end
            for _, quad in pairs(PlayerESPData[Player].Quads) do
                quad.Visible = false
            end
        end
    end
end

-- Cleanup function
local function ClearAllESP()
    for Player, _ in pairs(PlayerESPData) do
        RemovePlayerESP(Player)
    end
    PlayerESPData = {}
end

-- Player removal handler
local function OnPlayerRemoving(Player)
    RemovePlayerESP(Player)
end

-- Main connection
if ESPConnection then
    ESPConnection:Disconnect()
end

ESPConnection = RunService.Heartbeat:Connect(BoxESP) -- Using Heartbeat instead of RenderStepped
PlayersService.PlayerRemoving:Connect(OnPlayerRemoving)

-- Global function to disable ESP
_G.DisableBoxESP = function()
    ESPEnabled = false
    ClearAllESP()
end

-- Global function to enable ESP
_G.EnableBoxESP = function()
    ESPEnabled = true
end

-- Cleanup function
_G.CleanupBoxESP = function()
    if ESPConnection then
        ESPConnection:Disconnect()
        ESPConnection = nil
    end
    ClearAllESP()
end

-- Settings functions
_G.SetBoxESPDistance = function(distance)
    Settings.MaxDistance = distance
end

_G.SetBoxESPUpdateRate = function(rate)
    UPDATE_RATE = 1/rate
end
